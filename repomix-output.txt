This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-25T22:43:37.218Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.gitignore
client/.gitignore
client/package.json
client/postcss.config.js
client/public/index.html
client/public/manifest.json
client/public/robots.txt
client/README.md
client/src/App.css
client/src/App.js
client/src/App.test.js
client/src/components/ArtistRecommendations.js
client/src/components/ArtistTimeline.js
client/src/components/FestivalLineup.js
client/src/components/GenreDiversity.js
client/src/components/HiddenGems.js
client/src/components/ListeningComparison.js
client/src/components/ListeningTimeAnalysis.js
client/src/components/LoginButton.js
client/src/components/MoodAnalysis.js
client/src/components/MusicEvolution.js
client/src/components/MusicPersonality.js
client/src/components/NavBar.js
client/src/components/SeasonalPatterns.js
client/src/components/SongRepetitionPatterns.js
client/src/hooks/useSpotifyAuth.js
client/src/hooks/useSpotifyData.js
client/src/index.css
client/src/index.js
client/src/logo.svg
client/src/reportWebVitals.js
client/src/services/SpotifyApi.js
client/src/services/SpotifyAuth.js
client/src/setupTests.js
client/src/tailwind.config.js
client/tailwind.config.js
server/app.js
server/package.json
server/routes/spotify.js

================================================================
Repository Files
================================================================

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*

/server/.env
.env
*/.env
server/.env

================
File: client/.gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*

/server/.env

================
File: client/package.json
================
{
  "name": "client",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "bootstrap": "^5.3.3",
    "cra-template": "1.2.0",
    "framer-motion": "^11.15.0",
    "react": "^18.2.0",
    "react-bootstrap": "^2.10.7",
    "react-dom": "^18.2.0",
    "react-scripts": "5.0.1",
    "recharts": "^2.15.0",
    "spotify-web-api-js": "^1.5.2",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "autoprefixer": "^10.4.20",
    "postcss": "^8.4.49",
    "tailwindcss": "^3.4.17"
  }
}

================
File: client/postcss.config.js
================
module.exports = {
    plugins: {
      tailwindcss: {},
      autoprefixer: {},
    },
  }

================
File: client/public/index.html
================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>

================
File: client/public/manifest.json
================
{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}

================
File: client/public/robots.txt
================
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

================
File: client/README.md
================
# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in your browser.

The page will reload when you make changes.\
You may also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can't go back!**

If you aren't satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you're on your own.

You don't have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn't feel obligated to use this feature. However we understand that this tool wouldn't be useful if you couldn't customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

### Code Splitting

This section has moved here: [https://facebook.github.io/create-react-app/docs/code-splitting](https://facebook.github.io/create-react-app/docs/code-splitting)

### Analyzing the Bundle Size

This section has moved here: [https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size](https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size)

### Making a Progressive Web App

This section has moved here: [https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app](https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app)

### Advanced Configuration

This section has moved here: [https://facebook.github.io/create-react-app/docs/advanced-configuration](https://facebook.github.io/create-react-app/docs/advanced-configuration)

### Deployment

This section has moved here: [https://facebook.github.io/create-react-app/docs/deployment](https://facebook.github.io/create-react-app/docs/deployment)

### `npm run build` fails to minify

This section has moved here: [https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify](https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify)

================
File: client/src/App.css
================
/* Base Styles */
.App {
  min-height: 100vh;
  background-color: #121212;
  display: flex;
  flex-direction: column;
  align-items: stretch;
}

/* Button Styles */
button {
  background-color: #1DB954;
  color: white;
  border: none;
  padding: 15px 30px;
  border-radius: 50px;
  font-size: 16px;
  font-weight: bold;
  cursor: pointer;
  transition: background-color 0.3s;
}

button:hover {
  background-color: #1ed760;
}

h1 {
  color: white;
}

/* Navigation Styles */
.spotify-nav {
  background-color: #000000;
  padding: 20px;
  width: 100%;
  position: sticky;
  top: 0;
  z-index: 10;
}

.nav-content {
  max-width: 1200px;
  margin: 0 auto;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.nav-left {
  display: flex;
  align-items: center;
  gap: 20px;
}

.nav-logo {
  color: #1DB954;
  font-size: 24px;
  font-weight: bold;
}

.nav-welcome {
  color: #ffffff;
}

.nav-button {
  padding: 10px 20px;
  font-size: 14px;
}

/* Section Styles */
.sections-container {
  scroll-snap-type: y mandatory;
  overflow-y: scroll;
  height: calc(100vh - 80px);
  scroll-behavior: smooth;
}

.section {
  min-height: 100vh;
  width: 100%;
  position: relative;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  scroll-snap-align: start;
}

.section-1 { background-color: #121212; }
.section-2 { background-color: #181818; }
.section-3 { background-color: #282828; }

.section-content {
  opacity: 0;
  transform: translateY(20px);
  transition: all 0.6s ease-out;
  padding: 20px;
  text-align: center;
  color: white;
  width: 100%;
  max-width: 1200px;
}

.section-content.visible {
  opacity: 1;
  transform: translateY(0);
}

/* Dashboard Styles */
.dashboard {
  width: 100%;
  max-width: 1200px;
  margin: 20px auto;
  padding: 0 20px;
  flex: 1;
}

.analytics-grid {
  width: 100%;
  max-width: 1200px;
  margin: 0 auto;
}

/* Chart Styles */
.listening-time-card {
  background-color: #282828;
  padding: 30px;
  border-radius: 12px;
  margin: 20px;
  color: white;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  width: 100%;
}

.chart-title {
  font-size: 24px;
  font-weight: bold;
  margin-bottom: 20px;
  text-align: center;
  color: #fff;
}

.chart-wrapper {
  margin-top: 30px;
  background-color: #1a1a1a;
  padding: 20px;
  border-radius: 8px;
  width: 100%;
  min-height: 400px;
}

.listener-type {
  text-align: center;
  font-size: 18px;
  margin-bottom: 20px;
  color: #b3b3b3;
}

.listener-category {
  color: #1DB954;
  font-weight: bold;
  font-size: 20px;
  margin-left: 8px;
}

/* Loading State */
.loading {
  color: white;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  font-size: 1.5rem;
}
.section-content {
  opacity: 1; /* Changed from 0 */
  width: 100%;
  padding: 20px;
}

.analytics-grid {
  width: 100%;
  max-width: 1200px;
  margin: 0 auto;
  background-color: #181818;
}

================
File: client/src/App.js
================
import React, { useEffect, useState, useRef } from "react";
import { setAccessToken, getUserProfile } from "./services/SpotifyApi";
import useSpotifyAuth from "./hooks/useSpotifyAuth";
import { loginUrl } from "./services/SpotifyAuth";
import NavBar from "./components/NavBar";
import "./App.css";
import { useSpotifyData } from "./hooks/useSpotifyData";
import ListeningTimeAnalysis from "./components/ListeningTimeAnalysis";
import GenreDiversity from "./components/GenreDiversity";
import ArtistTimeline from "./components/ArtistTimeline";
import SongRepetitionPatterns from "./components/SongRepetitionPatterns";
import HiddenGems from "./components/HiddenGems";
import MusicEvolution from "./components/MusicEvolution";
import MusicPersonality from "./components/MusicPersonality";
import ListeningComparison from "./components/ListeningComparison";

import FestivalLineup from "./components/FestivalLineup";

function App() {
  const token = useSpotifyAuth();
  const [user, setUser] = useState(null);
  const sectionsRef = useRef([]);
  const { recentlyPlayed, topTracks, topArtists, audioFeatures, loading } =
    useSpotifyData();

  useEffect(() => {
    if (token) {
      setAccessToken(token);
      getUserProfile().then((userData) => {
        console.log("User Data:", userData);
        setUser(userData);
      });
    }
  }, [token]);

  // Handle scroll animations
  useEffect(() => {
    const observerOptions = {
      root: null,
      rootMargin: "0px",
      threshold: 0.3,
    };

    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          entry.target
            .querySelector(".section-content")
            .classList.add("visible");
        }
      });
    }, observerOptions);

    sectionsRef.current.forEach((section) => {
      if (section) observer.observe(section);
    });

    return () => observer.disconnect();
  }, []);

  // First check for token
  if (!token) {
    return (
      <div className="App">
        <a href={loginUrl}>
          <button>Login with Spotify</button>
        </a>
      </div>
    );
  }

  // Then check loading state
  if (loading) {
    return (
      <div className="App">
        <NavBar user={user} />
        <div className="loading">Loading your music data...</div>
      </div>
    );
  }
  console.log("App Data:", {
    recentlyPlayed,
    topTracks,
    topArtists,
    audioFeatures,
  });
  console.log("App render - recentlyPlayed data:", recentlyPlayed);
  // Main content render
  return (
    <div className="App">
      <NavBar user={user} />
      <div className="sections-container">
        <section
          className="section section-1"
          ref={(el) => (sectionsRef.current[0] = el)}
        >
          <div className="section-content">
            <h1>Welcome to Your Wrapped+</h1>
            <p>Scroll to explore your music journey</p>
          </div>
        </section>

        <section
          className="section section-2"
          ref={(el) => (sectionsRef.current[1] = el)}
        >
          <div className="section-content">
            <h2>Listening Time</h2>
            <div className="analytics-grid">
              {recentlyPlayed &&
                console.log("Recent Played Data available:", recentlyPlayed)}
              <ListeningTimeAnalysis recentlyPlayed={recentlyPlayed} />
            </div>
          </div>
        </section>

        <section
          className="section section-3"
          ref={(el) => (sectionsRef.current[2] = el)}
        >
          <div className="section-content">
            <h2>Genre Diversity</h2>
            {console.log(
              "Rendering GenreDiversity with topArtists:",
              topArtists
            )}
            <GenreDiversity topArtists={topArtists} />
          </div>
        </section>
        <section
          className="section section-4"
          ref={(el) => (sectionsRef.current[3] = el)}
        >
          <div className="section-content">
            <ArtistTimeline topArtists={topArtists} />
          </div>
        </section>
        <section
          className="section section-5"
          ref={(el) => (sectionsRef.current[4] = el)}
        >
          <div className="section-content">
            <SongRepetitionPatterns />
          </div>
        </section>
        <section
          className="section section-6"
          ref={(el) => (sectionsRef.current[5] = el)}
        >
          <div className="section-content">
            <HiddenGems />
          </div>
        </section>
        <section
          className="section section-8"
          ref={(el) => (sectionsRef.current[7] = el)}
        >
          <div className="section-content">
            <MusicEvolution />
          </div>
        </section>
        <section
          className="section section-9"
          ref={(el) => (sectionsRef.current[8] = el)}
        >
          <div className="section-content">
            <MusicPersonality />
          </div>
        </section>
        <section
          className="section section-10"
          ref={(el) => (sectionsRef.current[9] = el)}
        >
          <div className="section-content">
            <ListeningComparison />
          </div>
        </section>
        <section
          className="section section-11"
          ref={(el) => (sectionsRef.current[10] = el)}
        >
          <div className="section-content">
            <FestivalLineup />
          </div>
        </section>
      </div>
    </div>
  );
}

export default App;

================
File: client/src/App.test.js
================
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});

================
File: client/src/components/ArtistRecommendations.js
================
import React, { useEffect, useState, useCallback } from "react";
import * as SpotifyApi from "../services/SpotifyApi";

const ArtistRecommendations = () => {
  const [recommendations, setRecommendations] = useState([]);
  const [seedArtist, setSeedArtist] = useState(null);
  const [loading, setLoading] = useState(true);
  const [ setError] = useState(null);

  const getRecommendations = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      
      const topArtists = await SpotifyApi.getTopArtists('long_term', 1);
      console.log("Got top artists:", topArtists);
      
      if (!topArtists?.items?.length) {
        throw new Error("No top artists found");
      }
      
      const seedArtist = topArtists.items[0];
      setSeedArtist(seedArtist);
      
      const artistDetails = await SpotifyApi.getRecommendedArtists(seedArtist.id);
      
      if (artistDetails?.artists?.length) {
        setRecommendations(artistDetails.artists);
      } else {
        setRecommendations([]);
      }
    } catch (error) {
      console.error("Failed to get recommendations:", error);
      setError("Couldn't load recommendations right now");
      setRecommendations([]);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    getRecommendations();
  }, [getRecommendations]);

  if (loading) {
    return (
      <div className="section-content" style={{
        backgroundColor: '#282828',
        padding: '30px',
        borderRadius: '12px',
        color: '#b3b3b3',
        textAlign: 'center'
      }}>
        Finding your next favorite artists...
      </div>
    );
  }

  return (
    <div className="section-content" style={{
      backgroundColor: '#282828',
      padding: '30px',
      borderRadius: '12px',
      color: 'white'
    }}>
      <h3 style={{
        fontSize: '28px',
        textAlign: 'center',
        marginBottom: '20px',
        color: '#1DB954'
      }}>
        Artists You Might Love
      </h3>

      {seedArtist && recommendations.length > 0 && (
        <div style={{
          textAlign: 'center',
          marginBottom: '30px',
          color: '#b3b3b3'
        }}>
          Based on your love for <span style={{ color: '#fff', fontWeight: 'bold' }}>{seedArtist.name}</span>
        </div>
      )}

      {recommendations.length > 0 ? (
        <div style={{ 
          display: 'grid',
          gridTemplateColumns: 'repeat(auto-fit, minmax(280px, 1fr))',
          gap: '30px',
          padding: '20px'
        }}>
          {recommendations.map((artist, index) => (
            <div 
              key={artist.id || index}
              style={{
                backgroundColor: '#1a1a1a',
                padding: '25px',
                borderRadius: '16px',
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                textAlign: 'center',
                transition: 'all 0.3s ease',
                cursor: 'pointer',
              }}
              onMouseEnter={e => {
                e.currentTarget.style.transform = 'translateY(-5px)';
                e.currentTarget.style.backgroundColor = '#222';
              }}
              onMouseLeave={e => {
                e.currentTarget.style.transform = 'translateY(0)';
                e.currentTarget.style.backgroundColor = '#1a1a1a';
              }}
            >
              {artist.images?.[0] && (
                <img 
                  src={artist.images[0].url}
                  alt={artist.name}
                  style={{
                    width: '160px',
                    height: '160px',
                    borderRadius: '50%',
                    objectFit: 'cover',
                    marginBottom: '20px',
                    border: '4px solid #1DB954',
                    boxShadow: '0 4px 10px rgba(29, 185, 84, 0.3)'
                  }}
                />
              )}
              <h4 style={{ 
                fontSize: '22px',
                marginBottom: '12px',
                color: '#ffffff'
              }}>
                {artist.name}
              </h4>
              {artist.genres?.length > 0 && (
                <div style={{ 
                  color: '#1DB954',
                  fontSize: '16px',
                  marginBottom: '12px',
                  fontWeight: 'bold'
                }}>
                  {artist.genres.slice(0, 2).join(' â€¢ ')}
                </div>
              )}
              <div style={{ 
                color: '#b3b3b3',
                fontSize: '14px'
              }}>
                {artist.followers?.total?.toLocaleString() || 'N/A'} followers
              </div>
            </div>
          ))}
        </div>
      ) : (
        <div style={{ textAlign: 'center', color: '#b3b3b3' }}>
          No recommendations available right now
        </div>
      )}
    </div>
  );
};

export default ArtistRecommendations;

================
File: client/src/components/ArtistTimeline.js
================
import React, { useEffect, useState, useCallback } from 'react';
import * as SpotifyApi from '../services/SpotifyApi';

const ArtistTimeline = ({ topArtists }) => {
  const [artistHistory, setArtistHistory] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const COLORS = ['#1DB954', '#1ed760', '#169c46', '#0d5c29', '#2de26d'];

  console.log("Component rendered with topArtists:", topArtists);

  const fetchArtistHistory = useCallback(async () => {
    console.log("Fetching artist history...");
    try {
      // First get all top tracks
      const topTracks = await SpotifyApi.getPersonalTopTracks();
      console.log("User's top tracks:", topTracks);
  
      const historyData = await Promise.all(
        topArtists.items.slice(0, 10).map(async (artist) => {
          // Filter top tracks to find this artist's most played song
          const personalTopTrack = topTracks.items.find(track => 
            track.artists.some(a => a.id === artist.id)
          );
  
          return {
            ...artist,
            personalTopTrack: personalTopTrack || null,
            firstListened: new Date().setMonth(new Date().getMonth() - Math.floor(Math.random() * 12))
          };
        })
      );
  
      console.log("Processed history data:", historyData);
      setArtistHistory(historyData.sort((a, b) => a.firstListened - b.firstListened));
      setIsLoading(false);
    } catch (error) {
      console.error("Error fetching artist history:", error);
    }
  }, [topArtists]);

  useEffect(() => {
    if (topArtists?.items) {
      fetchArtistHistory();
    }
  }, [fetchArtistHistory]);

  const formatDate = (date) => {
    return new Date(date).toLocaleDateString('en-US', {
      month: 'long',
      year: 'numeric'
    });
  };

  if (isLoading) {
    return (
      <div className="section-content" style={{ color: 'white', textAlign: 'center' }}>
        Loading your artist journey...
      </div>
    );
  }

  return (
    <div className="section-content" style={{ 
      backgroundColor: '#282828',
      padding: '30px',
      borderRadius: '12px',
      color: 'white'
    }}>
      <h3 style={{ 
        fontSize: '24px', 
        textAlign: 'center',
        marginBottom: '30px'
      }}>
        Your Year, In Artists
      </h3>

      <div style={{ position: 'relative' }}>
        {artistHistory.map((artist, index) => (
          <div
            key={artist.id}
            style={{
              display: 'flex',
              alignItems: 'center',
              gap: '20px',
              backgroundColor: '#1a1a1a',
              padding: '20px',
              marginBottom: '20px',
              borderRadius: '12px',
              borderLeft: `4px solid ${COLORS[index % COLORS.length]}`
            }}
          >
            <div style={{ minWidth: '120px', color: '#b3b3b3' }}>
              {formatDate(artist.firstListened)}
            </div>

            {artist.images?.[0] && (
              <img
                src={artist.images[0].url}
                alt={artist.name}
                style={{
                  width: '80px',
                  height: '80px',
                  borderRadius: '50%',
                  objectFit: 'cover'
                }}
              />
            )}

            <div style={{ flex: 1 }}>
              <h4 style={{ 
                fontSize: '18px',
                marginBottom: '8px'
              }}>
                {artist.name}
              </h4>
              
              <div style={{ color: '#b3b3b3', marginBottom: '8px' }}>
                {artist.followers.total.toLocaleString()} followers
              </div>

              <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap' }}>
                {artist.genres.slice(0, 3).map((genre, i) => (
                  <span
                    key={i}
                    style={{
                      backgroundColor: COLORS[i % COLORS.length],
                      padding: '4px 12px',
                      borderRadius: '12px',
                      fontSize: '12px'
                    }}
                  >
                    {genre}
                  </span>
                ))}
              </div>

              {artist.personalTopTrack ? (
                <div style={{ 
                  marginTop: '8px',
                  color: '#b3b3b3',
                  fontSize: '14px'
                }}>
                  Your Most Played: {artist.personalTopTrack.name}
                </div>
              ) : (
                <div style={{ 
                  marginTop: '8px',
                  color: '#b3b3b3',
                  fontSize: '14px'
                }}>
                  No plays recorded yet
                </div>
              )}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

export default ArtistTimeline;

================
File: client/src/components/FestivalLineup.js
================
import React, { useEffect, useState, useCallback } from "react";
import * as SpotifyApi from "../services/SpotifyApi";

const FestivalLineup = () => {
  const [artists, setArtists] = useState({ headliners: [], mainActs: [], supportingActs: [] });
  const [loading, setLoading] = useState(true);
  const [username, setUsername] = useState("");

  const getLineup = useCallback(async () => {
    try {
      setLoading(true);
      
      const userProfile = await SpotifyApi.getUserProfile();
      setUsername(userProfile.display_name);

      const [longTerm, mediumTerm, shortTerm] = await Promise.all([
        SpotifyApi.getTopArtists("long_term", 20),
        SpotifyApi.getTopArtists("medium_term", 20),
        SpotifyApi.getTopArtists("short_term", 20),
      ]);

      const allArtists = [...longTerm.items, ...mediumTerm.items, ...shortTerm.items];
      const uniqueArtists = Array.from(new Set(allArtists.map((a) => a.id)))
        .map((id) => allArtists.find((a) => a.id === id));

      const shuffled = uniqueArtists.sort(() => Math.random() - 0.45);

      setArtists({
        headliners: shuffled.slice(0, 3),
        mainActs: shuffled.slice(3, 9),
        supportingActs: shuffled.slice(9, 21),
      });

      setLoading(false);
    } catch (error) {
      console.error("Error creating festival lineup:", error);
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    getLineup();
  }, [getLineup]);

  if (loading) {
    return <div className="section-content">Creating your festival lineup...</div>;
  }

  const currentYear = new Date().getFullYear();

  return (
    <div
      className="section-content"
      style={{
        backgroundColor: "#000",
        padding: "20px",
        color: "white",
        textAlign: "center",
        fontFamily: "Arial, sans-serif",
        backgroundImage: "linear-gradient(rgba(0,0,0,0.9), rgba(0,0,0,0.7))",
      }}
    >
      <div
        style={{
          maxWidth: "800px",
          margin: "0 auto",
          padding: "20px",
          border: "2px solid #1DB954",
          borderRadius: "10px",
          textAlign: "center",
        }}
      >
        <h1
          style={{
            fontSize: "3em",
            marginBottom: "15px",
            color: "#1DB954",
            textTransform: "uppercase",
            letterSpacing: "2px",
          }}
        >
          {username}'s FEST {currentYear}
        </h1>
        
        <p
          style={{
            marginBottom: "30px",
            color: "#b3b3b3",
            fontSize: "1.2em",
            textTransform: "uppercase",
          }}
        >
          Presented by Wrapped+
        </p>

        {/* Headliners */}
        <div style={{ marginBottom: "30px" }}>
          {artists.headliners.map((artist) => (
            <div
              key={artist.id}
              style={{
                fontSize: "2em",
                fontWeight: "bold",
                marginBottom: "10px",
                color: "#fff",
                textTransform: "uppercase",
                wordWrap: "break-word",
              }}
            >
              {artist.name}
            </div>
          ))}
        </div>

        {/* Main Acts */}
        <div
          style={{
            marginBottom: "20px",
            display: "flex",
            flexWrap: "wrap",
            justifyContent: "center",
            gap: "10px",
          }}
        >
          {artists.mainActs.map((artist) => (
            <div
              key={artist.id}
              style={{
                fontSize: "1.5em",
                color: "#1DB954",
                wordWrap: "break-word",
                textAlign: "center",
              }}
            >
              {artist.name}
            </div>
          ))}
        </div>

        {/* Supporting Acts */}
        <div
          style={{
            display: "flex",
            flexWrap: "wrap",
            justifyContent: "center",
            gap: "8px",
          }}
        >
          {artists.supportingActs.map((artist) => (
            <div
              key={artist.id}
              style={{
                fontSize: "1em",
                color: "#b3b3b3",
                wordWrap: "break-word",
                textAlign: "center",
              }}
            >
              {artist.name}
            </div>
          ))}
        </div>

        <p
          style={{
            marginTop: "30px",
            fontSize: "1em",
            color: "#1DB954",
            letterSpacing: "1px",
          }}
        >
          December {currentYear} â€¢ Your Music Universe
        </p>
      </div>
    </div>
  );
};

export default FestivalLineup;

================
File: client/src/components/GenreDiversity.js
================
import React, { useEffect, useState, useRef } from 'react';

const GenreDiversity = ({ topArtists }) => {
  const [genreData, setGenreData] = useState([]);
  const [isVisible, setIsVisible] = useState(false);
  const [selectedGenre, setSelectedGenre] = useState(null);
  const [artistsInGenre, setArtistsInGenre] = useState([]);
  const containerRef = useRef(null);
  const artistsRef = useRef(null);
  const COLORS = ['#1DB954', '#1ed760', '#169c46', '#0d5c29', '#2de26d', '#107a37'];

  // Intersection Observer for scroll animation
  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setIsVisible(true);
        }
      },
      { threshold: 0.2 }
    );

    if (containerRef.current) {
      observer.observe(containerRef.current);
    }

    return () => observer.disconnect();
  }, []);

  // Process genre data
  useEffect(() => {
    if (topArtists?.items) {
      const allGenres = topArtists.items.reduce((acc, artist) => {
        return [...acc, ...artist.genres];
      }, []);

      const genreCounts = allGenres.reduce((acc, genre) => {
        acc[genre] = (acc[genre] || 0) + 1;
        return acc;
      }, {});

      const sortedGenres = Object.entries(genreCounts)
        .map(([name, value]) => ({
          name: name.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' '),
          value
        }))
        .sort((a, b) => b.value - a.value)
        .slice(0, 6);

      setGenreData(sortedGenres);
    }
  }, [topArtists]);

  const handleGenreClick = (genre) => {
    // If same genre clicked, close it
    if (selectedGenre?.name === genre.name) {
      setSelectedGenre(null);
      setArtistsInGenre([]);
      return;
    }

    setSelectedGenre(genre);
    const artists = topArtists.items.filter(artist => 
      artist.genres.includes(genre.name.toLowerCase())
    );
    setArtistsInGenre(artists);

    // Smooth scroll to artists section
    setTimeout(() => {
      artistsRef.current?.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }, 100);
  };

  const maxValue = Math.max(...genreData.map(genre => genre.value));

  return (
    <div 
      ref={containerRef}
      style={{ 
        backgroundColor: '#282828', 
        padding: '30px',
        margin: '20px',
        borderRadius: '12px',
        color: 'white',
        opacity: isVisible ? 1 : 0,
        transform: isVisible ? 'translateY(0)' : 'translateY(50px)',
        transition: 'opacity 0.6s ease-out, transform 0.6s ease-out',
      }}
    >
      <h3 style={{ fontSize: '24px', marginBottom: '20px', textAlign: 'center' }}>
        Your Year in Genres
      </h3>

      <div style={{ 
        display: 'flex',
        flexWrap: 'wrap',
        gap: '20px',
        justifyContent: 'center',
        padding: '40px 20px',
      }}>

{genreData.map((genre, i) => (
  <div
    key={genre.name}
    onClick={() => handleGenreClick(genre)}
    style={{
      backgroundColor: COLORS[i],
      width: `${(genre.value / maxValue) * 200}px`,
      height: `${(genre.value / maxValue) * 200}px`,
      borderRadius: '50%',
      display: 'flex',
      flexDirection: 'column',
      justifyContent: 'center',
      alignItems: 'center',
      padding: '10px',  // Reduced padding
      textAlign: 'center',
      color: 'white',
      cursor: 'pointer',
      transition: 'all 0.3s ease',
      animation: isVisible ? `fadeIn 0.6s ease-out ${i * 0.2}s forwards` : 'none',
      opacity: 0,
      transform: selectedGenre?.name === genre.name ? 'scale(1.1)' : 'scale(0.8)',
      boxShadow: selectedGenre?.name === genre.name ? '0 0 20px rgba(29, 185, 84, 0.5)' : 'none',
    }}
  >
    <div style={{ 
      display: 'flex', 
      flexDirection: 'column', 
      gap: '4px',
      maxWidth: '80%'  // Constrain text width
    }}>
      <span style={{ 
        fontWeight: 'bold',
        fontSize: `${Math.max((genre.value / maxValue) * 16, 12)}px`,  // Responsive font size
        wordBreak: 'break-word',
        lineHeight: '1.2'
      }}>
        {genre.name}
      </span>
      <span style={{ 
        fontSize: `${Math.max((genre.value / maxValue) * 14, 10)}px`,  // Smaller font for count
        opacity: 0.9 
      }}>
        {genre.value} {genre.value === 1 ? 'Artist' : 'Artists'}
      </span>
    </div>
  </div>
))}
      </div>

      {/* Artists Section */}
      <div
        ref={artistsRef}
        style={{
          maxHeight: selectedGenre ? '800px' : '0',
          overflow: 'hidden',
          transition: 'all 0.5s ease-in-out',
          marginTop: selectedGenre ? '20px' : '0',
        }}
      >
        {selectedGenre && (
          <div style={{
            padding: '20px',
            backgroundColor: '#1a1a1a',
            borderRadius: '12px',
            maxHeight: '700px',  // Added max-height
            overflowY: 'auto',   // Added scroll for overflow
          }}>
            <h4 style={{ marginBottom: '20px', color: COLORS[0], position: 'sticky', top: 0, backgroundColor: '#1a1a1a', padding: '10px 0' }}>
              Top Artists in {selectedGenre.name}
            </h4>
            <div style={{
              display: 'grid',
              gridTemplateColumns: 'repeat(auto-fill, minmax(250px, 1fr))',
              gap: '15px',
              paddingBottom: '20px',
            }}>
              {artistsInGenre.map(artist => (
                <div 
                  key={artist.id} 
                  style={{
                    padding: '15px',
                    backgroundColor: '#282828',
                    borderRadius: '8px',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '15px',
                    transition: 'transform 0.3s ease',
                    cursor: 'pointer',
                  }}
                  onMouseEnter={e => e.currentTarget.style.transform = 'translateY(-5px)'}
                  onMouseLeave={e => e.currentTarget.style.transform = 'translateY(0)'}
                >
                  {artist.images?.[0] && (
                    <img 
                      src={artist.images[0].url} 
                      alt={artist.name}
                      style={{
                        width: '50px',
                        height: '50px',
                        borderRadius: '50%',
                        objectFit: 'cover',
                      }}
                    />
                  )}
                  <div>
                    <div style={{ fontWeight: 'bold' }}>{artist.name}</div>
                    <div style={{ fontSize: '14px', color: '#b3b3b3' }}>
                      {artist.followers.total.toLocaleString()} followers
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

// Add this to your CSS or App.css if not already present
const style = document.createElement('style');
style.textContent = `
  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: scale(0.8);
    }
    to {
      opacity: 1;
      transform: scale(1);
    }
  }
`;
document.head.appendChild(style);

export default GenreDiversity;

================
File: client/src/components/HiddenGems.js
================
import React, { useEffect, useState } from "react";
import * as SpotifyApi from "../services/SpotifyApi";

const HiddenGems = () => {
  const [hiddenGems, setHiddenGems] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const findHiddenGems = async () => {
      try {
        // Get user's top tracks
        const topTracks = await SpotifyApi.getPersonalTopTracks();
        console.log("Fetched top tracks:", topTracks);

        // Process tracks in batches to avoid rate limiting
        const batchSize = 5;
        const gems = [];
        
        for (let i = 0; i < Math.min(topTracks.items.length, 20); i += batchSize) {
          const batch = topTracks.items.slice(i, i + batchSize);
          
          // Add delay between batches
          if (i > 0) {
            await new Promise(resolve => setTimeout(resolve, 1000));
          }

          const batchResults = await Promise.all(
            batch.map(async (track) => {
              try {
                const artistInfo = await SpotifyApi.getArtistDetails(track.artists[0].id);
                return {
                  ...track,
                  artistFollowers: artistInfo.followers.total,
                  artistPopularity: artistInfo.popularity
                };
              } catch (error) {
                console.error(`Error fetching artist details for ${track.artists[0].name}:`, error);
                return null;
              }
            })
          );

          gems.push(...batchResults.filter(Boolean));
        }

        // Filter and sort the results
        const finalGems = gems
          .filter(track => track && track.artistFollowers < 500000)
          .sort((a, b) => b.popularity - a.popularity)
          .slice(0, 5);

        console.log("Found hidden gems:", finalGems);
        setHiddenGems(finalGems);
        setLoading(false);
      } catch (error) {
        console.error("Error finding hidden gems:", error);
        setLoading(false);
      }
    };

    findHiddenGems();
  }, []);

  if (loading) {
    return <div className="section-content">Discovering your hidden gems...</div>;
  }

  return (
    <div className="section-content" style={{ 
      backgroundColor: '#282828',
      padding: '30px',
      borderRadius: '12px',
      color: 'white'
    }}>
      <h3 style={{ 
        fontSize: '24px', 
        textAlign: 'center',
        marginBottom: '30px'
      }}>
        Your Hidden Gems
      </h3>

      <div style={{ marginBottom: '20px', textAlign: 'center', color: '#b3b3b3' }}>
        These are your favorite tracks from up-and-coming artists
      </div>

      {hiddenGems.map((track, index) => (
        <div
          key={track.id}
          style={{
            display: 'flex',
            alignItems: 'center',
            gap: '20px',
            backgroundColor: '#1a1a1a',
            padding: '20px',
            marginBottom: '15px',
            borderRadius: '12px',
          }}
        >
          {track.album.images[0] && (
            <img
              src={track.album.images[0].url}
              alt={track.name}
              style={{
                width: '60px',
                height: '60px',
                borderRadius: '4px'
              }}
            />
          )}
          
          <div style={{ flex: 1 }}>
            <div style={{ fontSize: '18px', marginBottom: '4px' }}>{track.name}</div>
            <div style={{ color: '#b3b3b3', fontSize: '14px' }}>
              {track.artists[0].name}
            </div>
            <div style={{ 
              color: '#1DB954', 
              fontSize: '12px',
              marginTop: '8px' 
            }}>
              Artist Followers: {track.artistFollowers.toLocaleString()}
            </div>
          </div>
        </div>
      ))}

      <div style={{ 
        marginTop: '30px',
        padding: '20px',
        backgroundColor: '#1a1a1a',
        borderRadius: '8px',
        textAlign: 'center'
      }}>
        <div style={{ color: '#1DB954', marginBottom: '10px' }}>ðŸ’Ž Did you know?</div>
        <div style={{ color: '#b3b3b3', fontSize: '14px' }}>
          You're among the top listeners for these artists on Spotify!
        </div>
      </div>
    </div>
  );
};

export default HiddenGems;

================
File: client/src/components/ListeningComparison.js
================
import React, { useEffect, useState, useCallback } from "react";
import * as SpotifyApi from "../services/SpotifyApi";
import { ResponsiveContainer, RadarChart, PolarGrid, PolarAngleAxis, Radar } from 'recharts';

const ListeningComparison = () => {
  const [comparisonData, setComparisonData] = useState(null);
  const [loading, setLoading] = useState(true);

  const analyzeDemographics = useCallback(async () => {
    try {
      const [userTracks, userArtists] = await Promise.all([
        SpotifyApi.getTopTracks('long_term', 50),
        SpotifyApi.getTopArtists('long_term', 50)
      ]);

      const userMetrics = calculateUserMetrics(userTracks, userArtists);
      const comparisonResults = compareWithDemographics(userMetrics);
      setComparisonData(comparisonResults);
      setLoading(false);
    } catch (error) {
      console.error("Demographics analysis error:", error);
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    analyzeDemographics();
  }, [analyzeDemographics]);

  const calculateUserMetrics = (tracks, artists) => {
    if (!tracks?.items?.length || !artists?.items?.length) return null;

    const popularityScores = tracks.items.map(track => track.popularity);
    const genreSet = new Set(artists.items.flatMap(artist => artist.genres));
    const releaseYears = tracks.items.map(track => new Date(track.album.release_date).getFullYear());
    const avgYear = releaseYears.reduce((a, b) => a + b) / releaseYears.length;

    return {
      avgPopularity: popularityScores.reduce((a, b) => a + b) / popularityScores.length,
      genreDiversity: genreSet.size,
      eraPreference: avgYear,
      mainstreamAlignment: popularityScores.filter(score => score > 75).length / popularityScores.length,
      artistVariety: new Set(tracks.items.map(track => track.artists[0].id)).size
    };
  };

  const compareWithDemographics = (userMetrics) => {
    if (!userMetrics) return null;

    const demographicRanges = {
      "Gen Z": {
        avgPopularity: 85,
        genreDiversity: 8,
        eraPreference: 2020,
        mainstreamAlignment: 0.8,
        artistVariety: 35
      },
      "Millennials": {
        avgPopularity: 75,
        genreDiversity: 12,
        eraPreference: 2010,
        mainstreamAlignment: 0.6,
        artistVariety: 45
      },
      "Gen X": {
        avgPopularity: 65,
        genreDiversity: 10,
        eraPreference: 1995,
        mainstreamAlignment: 0.4,
        artistVariety: 40
      }
    };

    const similarities = Object.entries(demographicRanges).map(([demo, metrics]) => {
      const score = calculateSimilarityScore(userMetrics, metrics);
      return { demographic: demo, similarity: score };
    });

    const closestDemographic = similarities.reduce((a, b) => 
      a.similarity > b.similarity ? a : b
    );

    return {
      userMetrics,
      demographicRanges,
      closestMatch: closestDemographic.demographic,
      similarityScore: closestDemographic.similarity,
      radarData: prepareRadarData(userMetrics, demographicRanges, closestDemographic.demographic)
    };
  };

  const calculateSimilarityScore = (user, demographic) => {
    const weights = {
      avgPopularity: 0.2,
      genreDiversity: 0.2,
      eraPreference: 0.3,
      mainstreamAlignment: 0.15,
      artistVariety: 0.15
    };

    return Object.keys(weights).reduce((score, metric) => {
      const normalizedDiff = Math.abs(user[metric] - demographic[metric]) / demographic[metric];
      return score - (normalizedDiff * weights[metric]);
    }, 1);
  };

  const prepareRadarData = (user, demographics, closestMatch) => {
    if (!user || !demographics || !closestMatch) return [];

    return Object.keys(user).map(metric => ({
      metric: metric.replace(/([A-Z])/g, ' $1').trim(),
      user: normalizeMetric(user[metric], metric),
      demographic: normalizeMetric(demographics[closestMatch][metric], metric)
    }));
  };

  const normalizeMetric = (value, metric) => {
    const ranges = {
      avgPopularity: [0, 100],
      genreDiversity: [0, 20],
      eraPreference: [1960, 2024],
      mainstreamAlignment: [0, 1],
      artistVariety: [0, 50]
    };

    const [min, max] = ranges[metric];
    return ((value - min) / (max - min)) * 100;
  };

  if (loading || !comparisonData) {
    return <div className="section-content">Analyzing demographic patterns...</div>;
  }

  return (
    <div className="section-content" style={{
      backgroundColor: '#282828',
      padding: '30px',
      borderRadius: '12px',
      color: 'white'
    }}>
      <h3 style={{
        fontSize: '24px',
        textAlign: 'center',
        marginBottom: '30px'
      }}>
        Your Music in Context
      </h3>

      <div style={{
        backgroundColor: '#1a1a1a',
        padding: '20px',
        borderRadius: '12px',
        marginBottom: '30px',
        textAlign: 'center'
      }}>
        <h4 style={{color: '#1DB954', marginBottom: '10px'}}>
          Your Listening Profile Most Closely Matches
        </h4>
        <div style={{fontSize: '24px', marginBottom: '10px'}}>
          {comparisonData.closestMatch}
        </div>
        <div style={{color: '#b3b3b3'}}>
          {(comparisonData.similarityScore * 100).toFixed(1)}% similarity
        </div>
      </div>

      <div style={{
        backgroundColor: '#1a1a1a',
        padding: '20px',
        borderRadius: '12px',
        height: '400px'
      }}>
        <ResponsiveContainer>
          <RadarChart data={comparisonData.radarData}>
            <PolarGrid stroke="#444" />
            <PolarAngleAxis dataKey="metric" stroke="#fff" />
            <Radar
              name="Your Profile"
              dataKey="user"
              stroke="#1DB954"
              fill="#1DB954"
              fillOpacity={0.3}
            />
            <Radar
              name="Demographic Average"
              dataKey="demographic"
              stroke="#b3b3b3"
              fill="#b3b3b3"
              fillOpacity={0.3}
            />
          </RadarChart>
        </ResponsiveContainer>
      </div>

      <div style={{
        backgroundColor: '#1a1a1a',
        padding: '20px',
        borderRadius: '12px',
        marginTop: '20px'
      }}>
        <h4 style={{color: '#1DB954', marginBottom: '15px'}}>What Makes You Unique</h4>
        <ul style={{listStyle: 'none', padding: 0}}>
          {generateUniqueTraits(comparisonData.userMetrics, 
                              comparisonData.demographicRanges[comparisonData.closestMatch])
            .map((trait, index) => (
              <li key={index} style={{marginBottom: '10px'}}>â€¢ {trait}</li>
          ))}
        </ul>
      </div>
    </div>
  );
};

const generateUniqueTraits = (user, demographic) => {
  if (!user || !demographic) return [];
  
  const traits = [];
  
  if (user.avgPopularity > demographic.avgPopularity + 10) {
    traits.push("You tend to discover trending music earlier than others");
  } else if (user.avgPopularity < demographic.avgPopularity - 10) {
    traits.push("You have a strong appreciation for underground music");
  }

  if (user.genreDiversity > demographic.genreDiversity + 2) {
    traits.push("Your taste in music is more diverse than average");
  }

  if (Math.abs(user.eraPreference - demographic.eraPreference) > 10) {
    traits.push(user.eraPreference > demographic.eraPreference ? 
      "You're more drawn to contemporary music" :
      "You have a stronger connection to classic tracks");
  }

  if (user.artistVariety > demographic.artistVariety + 5) {
    traits.push("You explore more artists than typical listeners");
  }

  return traits;
};

export default ListeningComparison;

================
File: client/src/components/ListeningTimeAnalysis.js
================
import React, { useEffect, useState } from 'react';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts';

const ListeningTimeAnalysis = ({ recentlyPlayed }) => {
  const [hourlyData, setHourlyData] = useState([]);
  const [listenerType, setListenerType] = useState('');

  const getPeakListeningInsight = (hourlyData) => {
    let peakHour = 0;
    let maxPlays = 0;
    let totalPlays = 0;
    
    hourlyData.forEach(data => {
      totalPlays += data.count;
      if (data.count > maxPlays) {
        maxPlays = data.count;
        peakHour = data.hour;
      }
    });

    const peakTimeFormatted = `${peakHour === 0 ? '12 AM' : 
      peakHour < 12 ? `${peakHour} AM` : 
      peakHour === 12 ? '12 PM' : 
      `${peakHour-12} PM`}`;

    return {
      peakTime: peakTimeFormatted,
      totalPlays,
      peakPlays: maxPlays
    };
  };

  const getListenerType = (hourlyData) => {
    let peakHour = 0;
    let maxPlays = 0;
    
    hourlyData.forEach(data => {
      if (data.count > maxPlays) {
        maxPlays = data.count;
        peakHour = data.hour;
      }
    });

    if (peakHour >= 0 && peakHour < 6) {
      return "Night Owl ðŸ¦‰";
    } else if (peakHour >= 6 && peakHour < 12) {
      return "Early Bird ðŸŒ…";
    } else if (peakHour >= 12 && peakHour < 17) {
      return "Afternoon Enthusiast â˜€ï¸";
    } else if (peakHour >= 17 && peakHour < 22) {
      return "Evening Listener ðŸŒ†";
    } else {
      return "Late Night Listener ðŸŒ™";
    }
  };

  useEffect(() => {
    console.log("Recent played data received:", recentlyPlayed);
    if (recentlyPlayed?.items) {
      // Initialize hours with better time formatting
      const hourCounts = Array.from({ length: 24 }, (_, i) => ({
        hour: i,
        count: 0,
        displayHour: `${i}:00`,
        timeOfDay: i < 12 ? 'AM' : 'PM',
        formattedHour: i === 0 ? '12 AM' : i < 12 ? `${i} AM` : i === 12 ? '12 PM' : `${i-12} PM`
      }));

      // Process each track
      recentlyPlayed.items.forEach(item => {
        const timestamp = new Date(item.played_at);
        const hour = timestamp.getHours();
        hourCounts[hour].count += 1;
      });

      console.log("Processed hourly data:", hourCounts);
      setHourlyData(hourCounts);
      setListenerType(getListenerType(hourCounts));
    }
  }, [recentlyPlayed]);

  if (!hourlyData.length) {
    return <div>Loading chart data...</div>;
  }

  return (
    <div style={{ 
      backgroundColor: '#282828', 
      padding: '30px', 
      margin: '20px',
      minHeight: '500px',
      width: '100%',
      color: 'white',
      borderRadius: '12px',
    }}>
      <h3 style={{ fontSize: '24px', marginBottom: '20px', textAlign: 'center' }}>
        Your Listening Patterns
      </h3>
      
      <div style={{ textAlign: 'center', marginBottom: '20px', color: '#b3b3b3' }}>
        You are a: <span style={{ color: '#1DB954', fontWeight: 'bold', fontSize: '20px' }}>{listenerType}</span>
      </div>

      <div style={{ 
        display: 'grid', 
        gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',
        gap: '20px',
        margin: '30px 0',
        padding: '20px',
        backgroundColor: '#1a1a1a',
        borderRadius: '8px'
      }}>
        <div style={{ textAlign: 'center' }}>
          <div style={{ color: '#1DB954', fontSize: '24px', fontWeight: 'bold' }}>
            {getPeakListeningInsight(hourlyData).peakTime}
          </div>
          <div style={{ color: '#b3b3b3', fontSize: '14px' }}>Peak Listening Time</div>
        </div>
        <div style={{ textAlign: 'center' }}>
          <div style={{ color: '#1DB954', fontSize: '24px', fontWeight: 'bold' }}>
            {getPeakListeningInsight(hourlyData).totalPlays}
          </div>
          <div style={{ color: '#b3b3b3', fontSize: '14px' }}>Total Tracks Played</div>
        </div>
        <div style={{ textAlign: 'center' }}>
          <div style={{ color: '#1DB954', fontSize: '24px', fontWeight: 'bold' }}>
            {getPeakListeningInsight(hourlyData).peakPlays}
          </div>
          <div style={{ color: '#b3b3b3', fontSize: '14px' }}>Most Plays in One Hour</div>
        </div>
      </div>

      <div style={{ height: '400px', width: '100%', backgroundColor: '#1a1a1a', padding: '20px', borderRadius: '8px' }}>
        <ResponsiveContainer>
          <LineChart data={hourlyData}>
            <CartesianGrid strokeDasharray="3 3" stroke="#444" />
            <XAxis 
              dataKey="formattedHour" 
              stroke="#fff"
              interval={2}
              tick={{ fontSize: 12 }}
            />
            <YAxis 
              stroke="#fff"
              tick={{ fontSize: 12 }}
              label={{ 
                value: 'Number of Plays', 
                angle: -90, 
                position: 'insideLeft',
                style: { fill: '#fff' }
              }}
            />
            <Tooltip 
              contentStyle={{
                backgroundColor: '#282828',
                border: '1px solid #1DB954',
                borderRadius: '4px',
                color: '#fff'
              }}
              formatter={(value) => [`${value} plays`]}
              labelFormatter={(label) => `Time: ${label}`}
            />
            <Line 
              type="monotone" 
              dataKey="count" 
              stroke="#1DB954" 
              strokeWidth={3}
              dot={{ fill: '#1DB954', stroke: '#1DB954', r: 4 }}
              activeDot={{ r: 6, fill: '#fff' }}
            />
          </LineChart>
        </ResponsiveContainer>
      </div>
    </div>
  );
};

export default ListeningTimeAnalysis;

================
File: client/src/components/LoginButton.js
================
// src/components/LoginButton.js
import React from "react";
import { loginUrl } from "../services/SpotifyAuth";

const LoginButton = () => (
  <a href={loginUrl}>
    <button>Login with Spotify</button>
  </a>
);

export default LoginButton;

================
File: client/src/components/MoodAnalysis.js
================
import React, { useState, useEffect, useCallback } from 'react';
import * as SpotifyApi from '../services/SpotifyApi';

const MoodAnalysis = () => {
  const [tracks, setTracks] = useState([]);
  const [isLoading, setIsLoading] = useState(true);

  const fetchMoodData = useCallback(async () => {
    try {
      console.log("Starting mood analysis fetch...");
      const tracksWithFeatures = await SpotifyApi.getTracksWithAudioFeatures();
      console.log("Got tracks with features:", tracksWithFeatures);
      setTracks(tracksWithFeatures);
      setIsLoading(false);
    } catch (error) {
      console.error("Error fetching mood data:", error);
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchMoodData();
  }, [fetchMoodData]);

  if (isLoading) {
    return (
      <div className="section-content" style={{ 
        backgroundColor: '#282828',
        padding: '30px',
        borderRadius: '12px',
        color: 'white',
        textAlign: 'center'
      }}>
        Analyzing your music moods...
      </div>
    );
  }

  // Basic stats calculation
  const averageStats = tracks.reduce((acc, track) => {
    // Check if track and audioFeatures exist and are not null
    if (track?.audioFeatures?.valence !== undefined) {
        acc.valence += track.audioFeatures.valence || 0;
        acc.energy += track.audioFeatures.energy || 0;
        acc.danceability += track.audioFeatures.danceability || 0;
        acc.validTracks++; // Count only tracks with valid features
    }
    return acc;
}, { valence: 0, energy: 0, danceability: 0, validTracks: 0 });

// Then calculate averages using validTracks count instead of total tracks
const validTracks = averageStats.validTracks || 1; // Prevent division by zero
const avgValence = (averageStats.valence / validTracks) * 100;
const avgEnergy = (averageStats.energy / validTracks) * 100;
const avgDanceability = (averageStats.danceability / validTracks) * 100;
  return (
    <div className="section-content" style={{ 
      backgroundColor: '#282828',
      padding: '30px',
      borderRadius: '12px',
      color: 'white'
    }}>
      <h3 style={{ 
        fontSize: '24px', 
        textAlign: 'center',
        marginBottom: '30px'
      }}>
        Your Music Mood Analysis
      </h3>

      <div style={{
        display: 'grid',
        gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))',
        gap: '20px',
        marginBottom: '30px'
      }}>
        {/* Mood Metrics */}
        <div style={{
          backgroundColor: '#1a1a1a',
          padding: '20px',
          borderRadius: '12px',
          textAlign: 'center'
        }}>
          <h4>Happiness Level</h4>
          <div style={{ fontSize: '24px', color: '#1DB954' }}>
            {avgValence.toFixed(1)}%
          </div>
        </div>

        <div style={{
          backgroundColor: '#1a1a1a',
          padding: '20px',
          borderRadius: '12px',
          textAlign: 'center'
        }}>
          <h4>Energy Level</h4>
          <div style={{ fontSize: '24px', color: '#1DB954' }}>
            {avgEnergy.toFixed(1)}%
          </div>
        </div>

        <div style={{
          backgroundColor: '#1a1a1a',
          padding: '20px',
          borderRadius: '12px',
          textAlign: 'center'
        }}>
          <h4>Danceability</h4>
          <div style={{ fontSize: '24px', color: '#1DB954' }}>
            {avgDanceability.toFixed(1)}%
          </div>
        </div>
      </div>

      {/* Sample of mood-analyzed tracks */}
      <div style={{
        backgroundColor: '#1a1a1a',
        padding: '20px',
        borderRadius: '12px',
      }}>
        <h4 style={{ marginBottom: '20px' }}>Your Mood Sample</h4>
        {tracks.slice(0, 5).map(track => (
          <div key={track.id} style={{
            display: 'flex',
            alignItems: 'center',
            gap: '15px',
            marginBottom: '15px',
            padding: '10px',
            backgroundColor: '#282828',
            borderRadius: '8px'
          }}>
            {track.album.images[0] && (
              <img 
                src={track.album.images[0].url}
                alt={track.name}
                style={{
                  width: '50px',
                  height: '50px',
                  borderRadius: '4px'
                }}
              />
            )}
            <div>
              <div style={{ fontWeight: 'bold' }}>{track.name}</div>
              <div style={{ color: '#b3b3b3', fontSize: '14px' }}>{track.artists[0].name}</div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

export default MoodAnalysis;

================
File: client/src/components/MusicEvolution.js
================
import React, { useEffect, useState } from "react";
import * as SpotifyApi from "../services/SpotifyApi";

const MusicEvolution = () => {
  const [timeRanges, setTimeRanges] = useState({
    short_term: null,   // Last 4 weeks
    medium_term: null,  // Last 6 months
    long_term: null    // All time
  });
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchTimeRangeData = async () => {
      try {
        // Fetch data for all time ranges
        const [shortTerm, mediumTerm, longTerm] = await Promise.all([
          SpotifyApi.getTopArtists('short_term', 10),
          SpotifyApi.getTopArtists('medium_term', 10),
          SpotifyApi.getTopArtists('long_term', 10)
        ]);

        setTimeRanges({
          short_term: shortTerm,
          medium_term: mediumTerm,
          long_term: longTerm
        });

        setLoading(false);
      } catch (error) {
        console.error("Error fetching evolution data:", error);
        setLoading(false);
      }
    };

    fetchTimeRangeData();
  }, []);

  const renderArtistList = (artists, timeRange) => {
    const timeLabels = {
      short_term: "Last 4 Weeks",
      medium_term: "Last 6 Months",
      long_term: "All Time"
    };

    return (
      <div style={{
        backgroundColor: '#1a1a1a',
        padding: '20px',
        borderRadius: '12px',
        flex: 1
      }}>
        <h4 style={{ 
          color: '#1DB954', 
          marginBottom: '15px',
          fontSize: '18px'
        }}>
          {timeLabels[timeRange]}
        </h4>
        {artists.items.map((artist, index) => (
          <div key={artist.id} style={{
            display: 'flex',
            alignItems: 'center',
            gap: '15px',
            marginBottom: '10px',
            padding: '10px',
            backgroundColor: '#282828',
            borderRadius: '8px',
          }}>
            {artist.images[0] && (
              <img 
                src={artist.images[0].url}
                alt={artist.name}
                style={{
                  width: '40px',
                  height: '40px',
                  borderRadius: '50%',
                  objectFit: 'cover'
                }}
              />
            )}
            <div>
              <div style={{ fontWeight: 'bold' }}>
                {index + 1}. {artist.name}
              </div>
              <div style={{ 
                fontSize: '12px',
                color: '#b3b3b3',
                marginTop: '4px'
              }}>
                {artist.genres.slice(0, 2).join(', ')}
              </div>
            </div>
          </div>
        ))}
      </div>
    );
  };

  if (loading) {
    return <div className="section-content">Analyzing your music evolution...</div>;
  }

  return (
    <div className="section-content" style={{ 
      backgroundColor: '#282828',
      padding: '30px',
      borderRadius: '12px',
      color: 'white'
    }}>
      <h3 style={{ 
        fontSize: '24px', 
        textAlign: 'center',
        marginBottom: '30px'
      }}>
        Your Music Evolution
      </h3>

      <div style={{
        display: 'grid',
        gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))',
        gap: '20px',
        marginBottom: '30px'
      }}>
        {Object.entries(timeRanges).map(([timeRange, data]) => (
          data && renderArtistList(data, timeRange)
        ))}
      </div>

      {/* Analysis section */}
      <div style={{
        backgroundColor: '#1a1a1a',
        padding: '20px',
        borderRadius: '12px',
        marginTop: '30px'
      }}>
        <h4 style={{ color: '#1DB954', marginBottom: '15px' }}>Evolution Insights</h4>
        <div style={{ color: '#b3b3b3' }}>
          Compare your listening patterns across different time periods to see how your music taste has evolved.
        </div>
      </div>
    </div>
  );
};

export default MusicEvolution;

================
File: client/src/components/MusicPersonality.js
================
import React, { useEffect, useState } from "react";
import * as SpotifyApi from "../services/SpotifyApi";

const PERSONALITY_TYPES = {
 "The Sonic Explorer": {
   description: "A musical adventurer constantly seeking new sounds and genres",
   traits: ["Diverse playlists", "High artist variety", "Genre-fluid"],
   icon: "ðŸŒŽ"
 },
 "The Genre Specialist": {
   description: "Deep expertise and appreciation for specific genres",
   traits: ["Genre loyal", "Artist encyclopedic knowledge", "Niche appreciation"],
   icon: "ðŸŽ¯"
 },
 "The Mood Maestro": {
   description: "Expert at matching music to emotions and moments",
   traits: ["Emotional connection", "Context-aware", "Playlist curator"],
   icon: "ðŸŽ­"
 },
 "The Trend Surfer": {
   description: "Always in tune with the latest hits and emerging artists",
   traits: ["Early adopter", "High playlist turnover", "Social listener"],
   icon: "ðŸŒŠ"
 },
 "The Classic Connoisseur": {
   description: "Appreciates timeless music with deep artist loyalty",
   traits: ["Long-term listener", "Complete albums", "Artist loyal"],
   icon: "ðŸŽµ"
 }
};

const MusicPersonality = () => {
 const [personality, setPersonality] = useState(null);
 const [loading, setLoading] = useState(true);

 useEffect(() => {
    const analyze = async () => {
      await analyzeDetailedPersonality();
    };
    analyze();
  }, []); // Add eslint exception here
  // eslint-disable-next-line react-hooks/exhaustive-deps
 const analyzeDetailedPersonality = async () => {
   try {
     const [topTracks, topArtists, recentTracks] = await Promise.all([
       SpotifyApi.getTopTracks('long_term', 50),
       SpotifyApi.getTopArtists('long_term', 50),
       SpotifyApi.getRecentlyPlayed(50)
     ]);

     // Advanced Analysis
     const analysis = {
       genreVariety: calculateGenreVariety(topArtists),
       artistLoyalty: calculateArtistLoyalty(topTracks),
       trendAlignment: calculateTrendAlignment(topArtists),
       listeningPatterns: analyzeListeningPatterns(recentTracks),
       musicEra: analyzeEra(topTracks)
     };

     const types = determinePersonalityTypes(analysis);
     
     setPersonality({
       primaryType: types.primary,
       secondaryType: types.secondary,
       traits: analysis,
       insights: generateInsights(analysis, types)
     });
     setLoading(false);
   } catch (error) {
     console.error("Analysis error:", error);
     setLoading(false);
   }
 };

 const calculateGenreVariety = (artists) => {
   const genres = new Set(artists.items.flatMap(artist => artist.genres));
   return genres.size / artists.items.length;
 };

 const calculateArtistLoyalty = (tracks) => {
   const artistCounts = tracks.items.reduce((acc, track) => {
     const artistId = track.artists[0].id;
     acc[artistId] = (acc[artistId] || 0) + 1;
     return acc;
   }, {});
   return Math.max(...Object.values(artistCounts)) / tracks.items.length;
 };

 const calculateTrendAlignment = (artists) => {
   const averagePopularity = artists.items.reduce((sum, artist) => sum + artist.popularity, 0) / artists.items.length;
   return averagePopularity / 100;
 };

 const analyzeListeningPatterns = (recentTracks) => {
   const hours = recentTracks.items.map(track => new Date(track.played_at).getHours());
   const mostCommonHour = hours.reduce((acc, hour) => {
     acc[hour] = (acc[hour] || 0) + 1;
     return acc;
   }, {});
   return Object.entries(mostCommonHour).sort((a, b) => b[1] - a[1])[0][0];
 };

 const analyzeEra = (tracks) => {
   const years = tracks.items.map(track => new Date(track.album.release_date).getFullYear());
   const averageYear = years.reduce((sum, year) => sum + year, 0) / years.length;
   return averageYear >= 2020 ? "Contemporary" : averageYear >= 2010 ? "Modern" : "Classic";
 };

 const determinePersonalityTypes = (analysis) => {
   const scores = {
     "The Sonic Explorer": analysis.genreVariety * 0.8 + (1 - analysis.artistLoyalty) * 0.2,
     "The Genre Specialist": (1 - analysis.genreVariety) * 0.7 + analysis.artistLoyalty * 0.3,
     "The Mood Maestro": analysis.genreVariety * 0.4 + analysis.trendAlignment * 0.6,
     "The Trend Surfer": analysis.trendAlignment * 0.8 + (1 - analysis.artistLoyalty) * 0.2,
     "The Classic Connoisseur": analysis.artistLoyalty * 0.7 + (1 - analysis.trendAlignment) * 0.3
   };

   const sortedTypes = Object.entries(scores).sort((a, b) => b[1] - a[1]);
   return {
     primary: sortedTypes[0][0],
     secondary: sortedTypes[1][0]
   };
 };

 const generateInsights = (analysis, types) => {
   const insights = [];
   
   if (analysis.genreVariety > 0.7) {
     insights.push("You have an exceptionally diverse taste in music");
   }
   if (analysis.artistLoyalty > 0.6) {
     insights.push("You form strong connections with your favorite artists");
   }
   if (analysis.trendAlignment > 0.8) {
     insights.push("You're always on top of the latest music trends");
   }
   
   insights.push(`Peak listening time: ${analysis.listeningPatterns}:00`);
   insights.push(`You gravitate towards ${analysis.musicEra.toLowerCase()} music`);

   return insights;
 };

 if (loading) {
   return <div className="section-content">Analyzing your music personality...</div>;
 }

 return (
   <div className="section-content" style={{
     backgroundColor: '#282828',
     padding: '30px',
     borderRadius: '12px',
     color: 'white'
   }}>
     <h3 style={{
       textAlign: 'center',
       marginBottom: '30px',
       fontSize: '24px'
     }}>
       {personality.primaryType} {PERSONALITY_TYPES[personality.primaryType].icon}
     </h3>

     {/* Primary Type Card */}
     <div style={{
       backgroundColor: '#1a1a1a',
       padding: '20px',
       borderRadius: '12px',
       marginBottom: '20px'
     }}>
       <h4 style={{color: '#1DB954'}}>Primary Music Personality</h4>
       <p>{PERSONALITY_TYPES[personality.primaryType].description}</p>
       <div style={{
         display: 'flex',
         flexWrap: 'wrap',
         gap: '10px',
         marginTop: '10px'
       }}>
         {PERSONALITY_TYPES[personality.primaryType].traits.map(trait => (
           <span key={trait} style={{
             backgroundColor: '#1DB954',
             padding: '4px 12px',
             borderRadius: '12px',
             fontSize: '12px'
           }}>
             {trait}
           </span>
         ))}
       </div>
     </div>

     {/* Stats Grid */}
     <div style={{
       display: 'grid',
       gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',
       gap: '20px',
       marginBottom: '20px'
     }}>
       <StatCard 
         title="Genre Variety"
         value={`${(personality.traits.genreVariety * 100).toFixed(0)}%`}
       />
       <StatCard 
         title="Artist Loyalty"
         value={`${(personality.traits.artistLoyalty * 100).toFixed(0)}%`}
       />
       <StatCard 
         title="Trend Alignment"
         value={`${(personality.traits.trendAlignment * 100).toFixed(0)}%`}
       />
     </div>

     {/* Secondary Type */}
     <div style={{
       backgroundColor: '#1a1a1a',
       padding: '20px',
       borderRadius: '12px',
       marginBottom: '20px'
     }}>
       <h4 style={{color: '#1DB954'}}>Secondary Trait</h4>
       <p>You also show characteristics of: {personality.secondaryType} {PERSONALITY_TYPES[personality.secondaryType].icon}</p>
     </div>

     {/* Insights Section */}
     <div style={{
       backgroundColor: '#1a1a1a',
       padding: '20px',
       borderRadius: '12px'
     }}>
       <h4 style={{color: '#1DB954', marginBottom: '15px'}}>Your Music Story</h4>
       <ul style={{listStyle: 'none', padding: 0}}>
         {personality.insights.map((insight, index) => (
           <li key={index} style={{marginBottom: '10px'}}>
             â€¢ {insight}
           </li>
         ))}
       </ul>
     </div>
   </div>
 );
};

const StatCard = ({ title, value }) => (
 <div style={{
   backgroundColor: '#1a1a1a',
   padding: '15px',
   borderRadius: '8px',
   textAlign: 'center'
 }}>
   <div style={{color: '#b3b3b3', fontSize: '14px'}}>{title}</div>
   <div style={{color: '#1DB954', fontSize: '24px', fontWeight: 'bold'}}>{value}</div>
 </div>
);

export default MusicPersonality;

================
File: client/src/components/NavBar.js
================
import React from 'react';

const NavBar = ({ user }) => {
  return (
    <nav className="spotify-nav">
      <div className="nav-content">
        <div className="nav-left">
          <span className="nav-logo">Wrapped+</span>
          {user && (
            <span className="nav-welcome">
              Welcome, {user.display_name}
            </span>
          )}
        </div>
        
        <div className="nav-right">
          {user && (
            <button 
              className="nav-button"
              onClick={() => {
                // We'll implement logout later
                console.log('Logout clicked');
              }}
            >
              Logout
            </button>
          )}
        </div>
      </div>
    </nav>
  );
};

export default NavBar;

================
File: client/src/components/SeasonalPatterns.js
================
import React, { useEffect, useState } from "react";
import { ResponsiveContainer, LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend } from 'recharts';
import * as SpotifyApi from "../services/SpotifyApi";

const SeasonalPatterns = () => {
  const [seasonalData, setSeasonalData] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const analyzeSeasonalPatterns = async () => {
      try {
        const recentTracks = await SpotifyApi.getRecentlyPlayed(50);
        console.log("Fetched recent tracks:", recentTracks);

        // Group tracks by month/season
        const monthlyData = Array.from({ length: 12 }, (_, i) => ({
          month: new Date(2024, i).toLocaleString('default', { month: 'long' }),
          count: 0,
          tracks: [],
          topGenres: new Set(),
        }));

        recentTracks.items.forEach(item => {
          const date = new Date(item.played_at);
          const monthIndex = date.getMonth();
          monthlyData[monthIndex].count++;
          monthlyData[monthIndex].tracks.push(item.track);
          
          // Add genres if available
          item.track.artists.forEach(artist => {
            if (artist.genres) {
              artist.genres.forEach(genre => {
                monthlyData[monthIndex].topGenres.add(genre);
              });
            }
          });
        });

        console.log("Processed seasonal data:", monthlyData);
        setSeasonalData(monthlyData);
        setLoading(false);
      } catch (error) {
        console.error("Error analyzing seasonal patterns:", error);
        setLoading(false);
      }
    };

    analyzeSeasonalPatterns();
  }, []);

  if (loading) {
    return <div className="section-content">Analyzing your seasonal patterns...</div>;
  }

  return (
    <div className="section-content" style={{ 
      backgroundColor: '#282828',
      padding: '30px',
      borderRadius: '12px',
      color: 'white'
    }}>
      <h3 style={{ 
        fontSize: '24px', 
        textAlign: 'center',
        marginBottom: '30px'
      }}>
        Your Seasonal Listening Patterns
      </h3>

      {/* Monthly listening chart */}
      <div style={{ 
        backgroundColor: '#1a1a1a',
        padding: '20px',
        borderRadius: '12px',
        marginBottom: '30px'
      }}>
        <h4 style={{ marginBottom: '20px' }}>Listening Activity Throughout the Year</h4>
        <div style={{ height: '300px' }}>
          <ResponsiveContainer>
            <LineChart data={seasonalData}>
              <CartesianGrid strokeDasharray="3 3" stroke="#444" />
              <XAxis 
                dataKey="month" 
                stroke="#fff"
                interval={0}
                angle={-45}
                textAnchor="end"
                height={60}
              />
              <YAxis stroke="#fff" />
              <Tooltip 
                contentStyle={{
                  backgroundColor: '#282828',
                  border: '1px solid #1DB954',
                  borderRadius: '4px',
                  color: '#fff'
                }}
              />
              <Line 
                type="monotone" 
                dataKey="count" 
                stroke="#1DB954" 
                strokeWidth={2}
                dot={{ fill: '#1DB954' }}
              />
            </LineChart>
          </ResponsiveContainer>
        </div>
      </div>

      {/* Seasonal highlights */}
      <div style={{
        display: 'grid',
        gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))',
        gap: '20px'
      }}>
        {['Winter', 'Spring', 'Summer', 'Fall'].map((season, index) => {
          const monthsData = seasonalData.slice(index * 3, (index * 3) + 3);
          const totalPlays = monthsData.reduce((sum, month) => sum + month.count, 0);
          
          return (
            <div key={season} style={{
              backgroundColor: '#1a1a1a',
              padding: '20px',
              borderRadius: '12px',
            }}>
              <h4 style={{ color: '#1DB954', marginBottom: '15px' }}>{season}</h4>
              <div style={{ color: '#b3b3b3', fontSize: '14px', marginBottom: '10px' }}>
                {totalPlays} plays
              </div>
              <div style={{ fontSize: '12px' }}>
                Peak listening month: {
                  monthsData.reduce((max, month) => 
                    month.count > max.count ? month : max
                  ).month
                }
              </div>
            </div>
          );
        })}
      </div>
    </div>
  );
};

export default SeasonalPatterns;

================
File: client/src/components/SongRepetitionPatterns.js
================
import React, { useEffect, useState } from "react";
import * as SpotifyApi from "../services/SpotifyApi";

const SongRepetitionPatterns = () => {
  const [yearlyTopTracks, setYearlyTopTracks] = useState([]);
  const [loading, setLoading] = useState(true);
  const [expanded, setExpanded] = useState(false); // Track whether the list is expanded

  useEffect(() => {
    const fetchYearlyTracks = async () => {
      try {
        const data = await SpotifyApi.getYearlyTopTracks(50);

        // Simulate play counts (replace with actual data if available)
        const tracksWithPlays = data.items.map((track) => ({
          ...track,
          playCount: Math.floor(Math.random() * 100) + 50, // Simulated play count
        }));

        setYearlyTopTracks(tracksWithPlays);
      } catch (error) {
        console.error("Error fetching yearly tracks:", error.message);
      } finally {
        setLoading(false);
      }
    };

    fetchYearlyTracks();
  }, []);

  const visibleTracks = expanded ? yearlyTopTracks : yearlyTopTracks.slice(0, 10); // Show all or top 10

  if (loading) {
    return (
      <div style={{ color: "#b3b3b3", textAlign: "center" }}>
        Loading your most played songs of the year...
      </div>
    );
  }

  if (!yearlyTopTracks.length) {
    return (
      <div style={{ color: "#b3b3b3", textAlign: "center" }}>
        No data available for your yearly top tracks.
      </div>
    );
  }

  return (
    <div
      style={{
        backgroundColor: "#282828",
        padding: "30px",
        borderRadius: "12px",
        color: "white",
      }}
    >
      <h3
        style={{
          fontSize: "24px",
          marginBottom: "20px",
          textAlign: "center",
        }}
      >
        Your Top Songs of the Year
      </h3>
      <ul style={{ listStyle: "none", padding: 0 }}>
        {visibleTracks.map((track, index) => (
          <li
            key={track.id}
            style={{
              display: "flex",
              alignItems: "flex-start",
              gap: "15px",
              marginBottom: "15px",
              backgroundColor: "#1a1a1a",
              padding: "15px",
              borderRadius: "8px",
            }}
          >
            {/* Album Art */}
            {track.album.images[0] && (
              <img
                src={track.album.images[0].url}
                alt={track.name}
                style={{
                  width: "50px",
                  height: "50px",
                  borderRadius: "4px",
                  objectFit: "cover",
                  flexShrink: 0,
                }}
              />
            )}

            {/* Track Info */}
            <div style={{ flex: 1 }}>
              {/* Track Name */}
              <div
                style={{
                  fontWeight: "bold",
                  fontSize: "16px",
                  wordWrap: "break-word",
                  overflowWrap: "break-word",
                }}
              >
                #{index + 1} {track.name}
              </div>

              {/* Artists */}
              <div
                style={{
                  color: "#b3b3b3",
                  fontSize: "14px",
                  marginTop: "4px",
                }}
              >
                {track.artists.map((artist) => artist.name).join(", ")}
              </div>

              {/* Play Count */}
              <div
                style={{
                  color: "#1DB954",
                  fontSize: "14px",
                  marginTop: "4px",
                }}
              >
                {track.playCount} plays
              </div>
            </div>
          </li>
        ))}
      </ul>
      <button
        onClick={() => setExpanded(!expanded)}
        style={{
          marginTop: "20px",
          padding: "10px 20px",
          backgroundColor: "#1DB954",
          border: "none",
          borderRadius: "8px",
          color: "white",
          cursor: "pointer",
        }}
      >
        {expanded ? "Show Less" : "Show More"}
      </button>
    </div>
  );
};

export default SongRepetitionPatterns;

================
File: client/src/hooks/useSpotifyAuth.js
================
// src/hooks/useSpotifyAuth.js
import { useState, useEffect } from "react";

const useSpotifyAuth = () => {
  const [token, setToken] = useState(null);

 // in useSpotifyAuth.js
useEffect(() => {
    const hash = window.location.hash;
    if (hash) {
      const token = new URLSearchParams(hash.substring(1)).get("access_token");
      if (token) {
        console.log("Token found:", token.substring(0, 5) + "..."); // Debug log
        localStorage.setItem("spotifyToken", token); // Make sure this line exists
        setToken(token);
        window.location.hash = "";
      }
    }
  }, []);

  return token;
};

export default useSpotifyAuth;

================
File: client/src/hooks/useSpotifyData.js
================
import { useState, useEffect } from "react";
import * as SpotifyApi from "../services/SpotifyApi";

export const useSpotifyData = () => {
  const [recentlyPlayed, setRecentlyPlayed] = useState(null);
  const [topArtists, setTopArtists] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        console.log("Starting to fetch data...");

        // Get recently played tracks
        const recentTracks = await SpotifyApi.getRecentlyPlayed();
        console.log("Got recent tracks:", recentTracks);
        setRecentlyPlayed(recentTracks);

        // Get top artists - with explicit error handling
        try {
          console.log("Attempting to fetch top artists...");
          const artistsData = await SpotifyApi.getTopArtists();
          console.log("Successfully got top artists:", artistsData);
          setTopArtists(artistsData);
        } catch (artistError) {
          console.error("Error fetching top artists:", artistError);
        }

        setLoading(false);
      } catch (err) {
        console.error("Error in data fetching:", err);
        setError(err);
        setLoading(false);
      }
    };

    fetchData();
  }, []);

  return { recentlyPlayed, topArtists, loading, error };
};

================
File: client/src/index.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

================
File: client/src/index.js
================
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();

================
File: client/src/logo.svg
================
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 841.9 595.3"><g fill="#61DAFB"><path d="M666.3 296.5c0-32.5-40.7-63.3-103.1-82.4 14.4-63.6 8-114.2-20.2-130.4-6.5-3.8-14.1-5.6-22.4-5.6v22.3c4.6 0 8.3.9 11.4 2.6 13.6 7.8 19.5 37.5 14.9 75.7-1.1 9.4-2.9 19.3-5.1 29.4-19.6-4.8-41-8.5-63.5-10.9-13.5-18.5-27.5-35.3-41.6-50 32.6-30.3 63.2-46.9 84-46.9V78c-27.5 0-63.5 19.6-99.9 53.6-36.4-33.8-72.4-53.2-99.9-53.2v22.3c20.7 0 51.4 16.5 84 46.6-14 14.7-28 31.4-41.3 49.9-22.6 2.4-44 6.1-63.6 11-2.3-10-4-19.7-5.2-29-4.7-38.2 1.1-67.9 14.6-75.8 3-1.8 6.9-2.6 11.5-2.6V78.5c-8.4 0-16 1.8-22.6 5.6-28.1 16.2-34.4 66.7-19.9 130.1-62.2 19.2-102.7 49.9-102.7 82.3 0 32.5 40.7 63.3 103.1 82.4-14.4 63.6-8 114.2 20.2 130.4 6.5 3.8 14.1 5.6 22.5 5.6 27.5 0 63.5-19.6 99.9-53.6 36.4 33.8 72.4 53.2 99.9 53.2 8.4 0 16-1.8 22.6-5.6 28.1-16.2 34.4-66.7 19.9-130.1 62-19.1 102.5-49.9 102.5-82.3zm-130.2-66.7c-3.7 12.9-8.3 26.2-13.5 39.5-4.1-8-8.4-16-13.1-24-4.6-8-9.5-15.8-14.4-23.4 14.2 2.1 27.9 4.7 41 7.9zm-45.8 106.5c-7.8 13.5-15.8 26.3-24.1 38.2-14.9 1.3-30 2-45.2 2-15.1 0-30.2-.7-45-1.9-8.3-11.9-16.4-24.6-24.2-38-7.6-13.1-14.5-26.4-20.8-39.8 6.2-13.4 13.2-26.8 20.7-39.9 7.8-13.5 15.8-26.3 24.1-38.2 14.9-1.3 30-2 45.2-2 15.1 0 30.2.7 45 1.9 8.3 11.9 16.4 24.6 24.2 38 7.6 13.1 14.5 26.4 20.8 39.8-6.3 13.4-13.2 26.8-20.7 39.9zm32.3-13c5.4 13.4 10 26.8 13.8 39.8-13.1 3.2-26.9 5.9-41.2 8 4.9-7.7 9.8-15.6 14.4-23.7 4.6-8 8.9-16.1 13-24.1zM421.2 430c-9.3-9.6-18.6-20.3-27.8-32 9 .4 18.2.7 27.5.7 9.4 0 18.7-.2 27.8-.7-9 11.7-18.3 22.4-27.5 32zm-74.4-58.9c-14.2-2.1-27.9-4.7-41-7.9 3.7-12.9 8.3-26.2 13.5-39.5 4.1 8 8.4 16 13.1 24 4.7 8 9.5 15.8 14.4 23.4zM420.7 163c9.3 9.6 18.6 20.3 27.8 32-9-.4-18.2-.7-27.5-.7-9.4 0-18.7.2-27.8.7 9-11.7 18.3-22.4 27.5-32zm-74 58.9c-4.9 7.7-9.8 15.6-14.4 23.7-4.6 8-8.9 16-13 24-5.4-13.4-10-26.8-13.8-39.8 13.1-3.1 26.9-5.8 41.2-7.9zm-90.5 125.2c-35.4-15.1-58.3-34.9-58.3-50.6 0-15.7 22.9-35.6 58.3-50.6 8.6-3.7 18-7 27.7-10.1 5.7 19.6 13.2 40 22.5 60.9-9.2 20.8-16.6 41.1-22.2 60.6-9.9-3.1-19.3-6.5-28-10.2zM310 490c-13.6-7.8-19.5-37.5-14.9-75.7 1.1-9.4 2.9-19.3 5.1-29.4 19.6 4.8 41 8.5 63.5 10.9 13.5 18.5 27.5 35.3 41.6 50-32.6 30.3-63.2 46.9-84 46.9-4.5-.1-8.3-1-11.3-2.7zm237.2-76.2c4.7 38.2-1.1 67.9-14.6 75.8-3 1.8-6.9 2.6-11.5 2.6-20.7 0-51.4-16.5-84-46.6 14-14.7 28-31.4 41.3-49.9 22.6-2.4 44-6.1 63.6-11 2.3 10.1 4.1 19.8 5.2 29.1zm38.5-66.7c-8.6 3.7-18 7-27.7 10.1-5.7-19.6-13.2-40-22.5-60.9 9.2-20.8 16.6-41.1 22.2-60.6 9.9 3.1 19.3 6.5 28.1 10.2 35.4 15.1 58.3 34.9 58.3 50.6-.1 15.7-23 35.6-58.4 50.6zM320.8 78.4z"/><circle cx="420.9" cy="296.5" r="45.7"/><path d="M520.5 78.1z"/></g></svg>

================
File: client/src/reportWebVitals.js
================
const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;

================
File: client/src/services/SpotifyApi.js
================
import SpotifyWebApi from "spotify-web-api-js";

const spotifyApi = new SpotifyWebApi();

export const setAccessToken = (token) => {
  console.log("Setting access token:", token ? "Token exists" : "No token");
  if (token) {
    spotifyApi.setAccessToken(token);
    localStorage.setItem("spotifyToken", token); // Save token to localStorage
  }
};

export const getRecentlyPlayed = async (limit = 50) => {
  const token = localStorage.getItem("spotifyToken");
  console.log("Getting recently played with token:", token ? "Token exists" : "No token");

  if (!token) {
    throw new Error("No access token available");
  }

  spotifyApi.setAccessToken(token); // Ensure token is set before request
  return spotifyApi.getMyRecentlyPlayedTracks({ limit });
};

export const getUserProfile = async () => {
  const token = localStorage.getItem("spotifyToken");
  if (token) {
    spotifyApi.setAccessToken(token);
  }
  return spotifyApi.getMe();
};

export const getTopTracks = async (timeRange = "short_term", limit = 50) => {
  const token = localStorage.getItem("spotifyToken");
  if (token) {
    spotifyApi.setAccessToken(token);
  }
  return spotifyApi.getMyTopTracks({ time_range: timeRange, limit });
};

export const getTopArtists = async (timeRange = "long_term", limit = 50) => {
  const token = localStorage.getItem("spotifyToken");
  console.log("Token for top artists:", token ? "exists" : "missing");
  if (token) {
    spotifyApi.setAccessToken(token);
  }
  console.log("About to call getMyTopArtists with params:", { timeRange, limit });
  const result = await spotifyApi.getMyTopArtists({ time_range: timeRange, limit });
  console.log("getTopArtists result:", result);
  return result;
};

export const getAudioFeatures = async (trackIds) => {
  const token = localStorage.getItem("spotifyToken");
  if (token) {
    spotifyApi.setAccessToken(token);
  }
  return spotifyApi.getAudioFeaturesForTracks(trackIds);
};

export const getRecentlyPlayedHistory = async () => {
  const token = localStorage.getItem("spotifyToken");
  if (!token) {
    throw new Error("No access token");
  }
  spotifyApi.setAccessToken(token);
  // Get maximum allowed historical data
  return spotifyApi.getMyRecentlyPlayedTracks({ limit: 50, before: Date.now() });
};

export const getArtistHistory = async (artistId) => {
  const token = localStorage.getItem("spotifyToken");
  if (!token) {
    throw new Error("No access token");
  }
  spotifyApi.setAccessToken(token);
  return spotifyApi.getArtistTopTracks(artistId, "US");
};

export const getPersonalTopTracks = async () => {
  const token = localStorage.getItem("spotifyToken");
  if (!token) {
    throw new Error("No access token");
  }
  spotifyApi.setAccessToken(token);
  // Get more tracks to ensure we have enough data per artist
  return spotifyApi.getMyTopTracks({ limit: 50, time_range: "long_term" });
};

export const getTracksWithAudioFeatures = async () => {
  const token = localStorage.getItem("spotifyToken");
  if (!token) {
    throw new Error("No access token");
  }

  try {
    spotifyApi.setAccessToken(token);

    console.log("Starting to fetch top tracks...");
    const topTracks = await spotifyApi.getMyTopTracks({
      limit: 20, // Reduced limit for testing
      time_range: "long_term",
    });
    console.log("Successfully fetched top tracks:", topTracks);

    const trackIds = topTracks.items.map((track) => track.id);
    console.log("Track IDs:", trackIds);

    const features = await spotifyApi.getAudioFeaturesForTracks(trackIds);
    console.log("Audio features:", features);

    return topTracks.items.map((track, index) => ({
      ...track,
      audioFeatures: features.audio_features?.[index] || null,
    }));
  } catch (error) {
    console.error("Detailed error:", error.response || error);
    throw error;
  }
};
export const getYearlyTopTracks = async (limit = 50) => {
  const token = localStorage.getItem("spotifyToken");
  if (token) {
    spotifyApi.setAccessToken(token);
  }
  console.log("Fetching top tracks for the year (long_term)");
  try {
    return await spotifyApi.getMyTopTracks({ time_range: "long_term", limit });
  } catch (error) {
    console.error("Error fetching yearly top tracks:", error.message);
    throw error;
  }
};
export const getArtistDetails = async (artistId) => {
  const token = localStorage.getItem('spotifyToken');
  if (!token) {
    throw new Error("No access token");
  }
  spotifyApi.setAccessToken(token);
  return spotifyApi.getArtist(artistId);
};
export const getRecommendedArtists = async (artistId) => {
  const token = localStorage.getItem('spotifyToken');
  if (!token) throw new Error("No access token");
  
  spotifyApi.setAccessToken(token);
  
  try {
    console.log("Getting top tracks for artist:", artistId);
    // Get artist's top tracks first
    const topTracks = await spotifyApi.getArtistTopTracks(artistId, 'US');
    
    if (!topTracks.tracks.length) {
      throw new Error("No top tracks found for artist");
    }

    console.log("Got top tracks, getting recommendations");
    // Use these tracks to get recommendations
    const recommendations = await spotifyApi.getRecommendations({
      seed_tracks: [topTracks.tracks[0].id],
      min_popularity: 50,
      limit: 6
    });

    // Get full artist details
    const artistIds = [...new Set(recommendations.tracks.map(track => track.artists[0].id))];
    console.log("Getting full details for artists:", artistIds);
    const artistDetails = await spotifyApi.getArtists(artistIds);

    console.log("Got recommendations:", artistDetails);
    return artistDetails;
  } catch (error) {
    console.error("Spotify API error:", error);
    return { artists: [] };
  }
};

================
File: client/src/services/SpotifyAuth.js
================
const loginUrl = "http://localhost:5000/api/spotify/login";

export { loginUrl };

================
File: client/src/setupTests.js
================
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';

================
File: client/src/tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
module.exports = {
    content: [
      "./src/**/*.{js,jsx,ts,tsx}",
    ],
    theme: {
      extend: {},
    },
    plugins: [],
  }

================
File: client/tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [],
  theme: {
    extend: {},
  },
  plugins: [],
}

================
File: server/app.js
================
const express = require("express");
const cors = require("cors");
const dotenv = require("dotenv");
const spotifyRoutes = require("./routes/spotify");

// Load environment variables before using them
dotenv.config();

// Verify environment variables are loaded
console.log('Checking environment variables:');
console.log('Client ID:', process.env.SPOTIFY_CLIENT_ID ? 'Found' : 'Missing');
console.log('Client Secret:', process.env.SPOTIFY_CLIENT_SECRET ? 'Found' : 'Missing');
console.log('Redirect URI:', process.env.SPOTIFY_REDIRECT_URI ? 'Found' : 'Missing');

const app = express();

// Configure CORS for development
app.use(cors({
  origin: 'http://localhost:3000', // React app's address
  methods: ['GET', 'POST'],
  credentials: true
}));

app.use("/api/spotify", spotifyRoutes);

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
  console.log(`Callback URL: ${process.env.SPOTIFY_REDIRECT_URI}`);
});

================
File: server/package.json
================
{
    "name": "server",
    "version": "1.0.0",
    "description": "",
    "main": "app.js",
    "scripts": {
      "start": "node app.js"
    },
    "dependencies": {
      "express": "^4.18.2",
      "axios": "^1.5.0",
      "cors": "^2.8.5",
      "dotenv": "^16.0.3"
    }
  }

================
File: server/routes/spotify.js
================
const express = require("express");
const axios = require("axios");
const router = express.Router();
const dotenv = require('dotenv');

// Ensure environment variables are loaded
dotenv.config();

// Log environment variables on startup (remove in production)
console.log('Environment variables check:');
console.log('SPOTIFY_CLIENT_ID:', process.env.SPOTIFY_CLIENT_ID ? 'Present' : 'Missing');
console.log('SPOTIFY_CLIENT_SECRET:', process.env.SPOTIFY_CLIENT_SECRET ? 'Present' : 'Missing');
console.log('SPOTIFY_REDIRECT_URI:', process.env.SPOTIFY_REDIRECT_URI ? 'Present' : 'Missing');

// Step 1: Redirect user to Spotify login
router.get("/login", (req, res) => {
  const scopes = [
    "user-read-private",
    "user-read-email",
    "user-read-recently-played",
    "user-read-playback-state",
    "user-read-currently-playing",
    "user-top-read",         // Make sure this is here
    "playlist-read-private",
    "streaming",
    "user-read-email",
    "user-read-recently-played",
    "user-read-playback-state",
    "user-read-currently-playing",
    "playlist-read-private",
    
];
  // Construct the auth URL with proper environment variables
  const authUrl = `https://accounts.spotify.com/authorize?` + 
    `client_id=${process.env.SPOTIFY_CLIENT_ID}` +
    `&response_type=code` +
    `&redirect_uri=${encodeURIComponent(process.env.SPOTIFY_REDIRECT_URI)}` +
    `&scope=${encodeURIComponent(scopes.join(" "))}`;

  // Log the constructed URL (remove in production)
  console.log('Redirecting to:', authUrl);
  
  res.redirect(authUrl);
});

// Step 2: Handle the callback from Spotify
router.get("/callback", async (req, res) => {
  const code = req.query.code;

  try {
    const response = await axios.post(
      "https://accounts.spotify.com/api/token",
      new URLSearchParams({
        grant_type: "authorization_code",
        code: code,
        redirect_uri: process.env.SPOTIFY_REDIRECT_URI,
        client_id: process.env.SPOTIFY_CLIENT_ID,
        client_secret: process.env.SPOTIFY_CLIENT_SECRET,
      }).toString(),
      {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        }
      }
    );

    // After successful token exchange, redirect to frontend with token
    const redirectUrl = `http://localhost:3000/#access_token=${response.data.access_token}`;
    res.redirect(redirectUrl);
    
  } catch (error) {
    console.error("Error exchanging code for tokens:", error.response?.data || error.message);
    res.status(500).send("Authentication failed.");
  }
});

module.exports = router;
